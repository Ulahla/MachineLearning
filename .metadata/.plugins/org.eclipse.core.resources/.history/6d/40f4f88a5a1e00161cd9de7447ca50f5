package de.htw.ml;

import java.io.IOException;
import java.util.Arrays;

import org.jblas.FloatMatrix;
import org.jblas.util.Random;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.XYChart;
import javafx.stage.Stage;

public class Ue05_Sarah_Baumann extends Application {

	public static final String title = "Line Chart";
	public static final String xAxisLabel = "Car Index";
	public static final String yAxisLabel = "mpg";
	
	public static void main(String[] args) throws IOException {
		FloatMatrix cars = FloatMatrix.loadCSVFile("cars_jblas.csv");
		FloatMatrix cars_norm = normalize(cars);
		System.out.println(Arrays.toString(cars_norm.getColumn(1).toArray()));

		// TODO plotte die RMSE Werte
		float[] yVals = cars.getColumn(6).toArray();
		
//		Random.seed(7);
		Random.seed(7);
		FloatMatrix theta = FloatMatrix.rand(6, 1);
		System.out.println(theta);
		
		plot(yVals); 
	}

	
	
	// ---------------------------------------------------------------------------------
	// ------------ Alle Ã„nderungen ab hier geschehen auf eigene Gefahr ----------------
	// ---------------------------------------------------------------------------------
	
	/**
	 * Equivalent zu linspace in Octave
	 * 
	 * @param lower
	 * @param upper
	 * @param num
	 * @return
	 */
	private static FloatMatrix linspace(float lower, float upper, int num) {
        float[] data = new float[num];
        float step = Math.abs(lower-upper) / (num-1);
        for (int i = 0; i < num; i++)
            data[i] = lower + (step * i);
        data[0] = lower;
        data[data.length-1] = upper;
        return new FloatMatrix(data);
    }
	
	private static float[] dataY;
	
	/**
	 * Startet die eigentliche Applikation
	 * 
	 * @param gdppp
	 * @param lifespan
	 * @param xValues
	 * @param yValues
	 * @param args
	 */
	public static void plot(float[] yValues) {
		dataY = yValues;
		Application.launch(new String[0]);
	}
	
	/**
	 * Zeichnet das Diagram
	 */
	@SuppressWarnings("unchecked")
	@Override public void start(Stage stage) {

		stage.setTitle(title);
		
		final NumberAxis xAxis = new NumberAxis();
		xAxis.setLabel(xAxisLabel);
        final NumberAxis yAxis = new NumberAxis();
        yAxis.setLabel(yAxisLabel);
        
		final LineChart<Number, Number> sc = new LineChart<>(xAxis, yAxis);

		XYChart.Series<Number, Number> series1 = new XYChart.Series<>();
		series1.setName("Data");
		for (int i = 0; i < dataY.length; i++) {
			series1.getData().add(new XYChart.Data<Number, Number>(i, dataY[i]));
		}

		sc.setAnimated(false);
		sc.setCreateSymbols(true);

		sc.getData().addAll(series1);

		Scene scene = new Scene(sc, 500, 400);
		stage.setScene(scene);
		stage.show();
    }
	
	/**
	 * Normalisiert Werte
	 * @param column - column, which should get normalized
	 */
	public static FloatMatrix normalize(FloatMatrix matrix){
		FloatMatrix max = matrix.columnMaxs();
		FloatMatrix min = matrix.columnMins();
		return matrix.subRowVector(min).divi(max.subi(min));
	}
	
	/**
	 * Denormalisiert Werte
	 * @param column, die zu denormalisierte Spalte
	 * @param zielwerte, die Werte, mit denen denormalisiert wird
	 */
	public FloatMatrix deNormalize(FloatMatrix normMatrix, FloatMatrix zielwerte){
		FloatMatrix max = zielwerte.columnMaxs();
		FloatMatrix min = zielwerte.columnMins();
		return normMatrix.mulRowVector(max.subi(min)).addi(min);
	}
	
	/**
	 * calculates rmse for a column
	 * @param prediction , calculated prediction
	 * @param zielwerte, real values
	 */
	public float calcRMSE(FloatMatrix prediction, FloatMatrix zielwerte){
		float sum = 0;
		sum = prediction.subRowVector(zielwerte).mul(prediction.subRowVector(zielwerte)).sum();
		return (float) Math.sqrt(sum/zielwerte.length);
	}
	
	/**
	 * calculate prediction
	 */
	public FloatMatrix calcPredict(FloatMatrix matrixNorm, FloatMatrix koeffs){
		return matrixNorm.mulRowVector(koeffs);
	}
	
}
